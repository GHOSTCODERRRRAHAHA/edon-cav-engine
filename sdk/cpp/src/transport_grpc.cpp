/**
 * @file transport_grpc.cpp
 * @brief gRPC transport implementation
 */

#include "edon/transport.hpp"
#include <grpcpp/grpcpp.h>
#include <memory>
#include <thread>
#include <chrono>
#include <stdexcept>

// Include generated protobuf headers (generated by CMake)
#include "edon.pb.h"
#include "edon.grpc.pb.h"

namespace edon {

class GRPCTransport::Impl {
public:
    Impl(const std::string& host, int port) {
        std::string address = host + ":" + std::to_string(port);
        channel_ = grpc::CreateChannel(address, grpc::InsecureChannelCredentials());
        stub_ = edon::v1::EdonService::NewStub(channel_);
    }
    
    ~Impl() = default;
    
    std::shared_ptr<grpc::Channel> channel() { return channel_; }
    std::unique_ptr<edon::v1::EdonService::Stub>& stub() { return stub_; }
    
private:
    std::shared_ptr<grpc::Channel> channel_;
    std::unique_ptr<edon::v1::EdonService::Stub> stub_;
};

GRPCTransport::GRPCTransport(const std::string& host, int port)
    : pimpl_(std::make_unique<Impl>(host, port))
{
}

GRPCTransport::~GRPCTransport() = default;

CAVResponse GRPCTransport::computeCAV(const SensorWindow& window) {
    // Build protobuf request
    edon::v1::CavRequest request;
    request.mutable_eda()->Assign(window.eda.begin(), window.eda.end());
    request.mutable_temp()->Assign(window.temp.begin(), window.temp.end());
    request.mutable_bvp()->Assign(window.bvp.begin(), window.bvp.end());
    request.mutable_acc_x()->Assign(window.acc_x.begin(), window.acc_x.end());
    request.mutable_acc_y()->Assign(window.acc_y.begin(), window.acc_y.end());
    request.mutable_acc_z()->Assign(window.acc_z.begin(), window.acc_z.end());
    request.set_temp_c(window.temp_c);
    request.set_humidity(window.humidity);
    request.set_aqi(window.aqi);
    request.set_local_hour(window.local_hour);
    
    // Call gRPC
    edon::v1::CavResponse response;
    grpc::ClientContext context;
    
    grpc::Status status = pimpl_->stub()->GetState(&context, request, &response);
    
    if (!status.ok()) {
        throw std::runtime_error("gRPC call failed: " + status.error_message());
    }
    
    // Convert to CAVResponse
    CAVResponse result;
    result.cav_raw = response.cav_raw();
    result.cav_smooth = response.cav_smooth();
    result.state = response.state();
    result.parts.bio = response.parts().bio();
    result.parts.env = response.parts().env();
    result.parts.circadian = response.parts().circadian();
    result.parts.p_stress = response.parts().p_stress();
    result.controls.speed = response.controls().speed();
    result.controls.torque = response.controls().torque();
    result.controls.safety = response.controls().safety();
    result.timestamp_ms = response.timestamp_ms();
    
    return result;
}

void GRPCTransport::stream(
    const SensorWindow& window,
    std::function<void(const CAVResponse&)> callback,
    bool stream_mode
) {
    // Build protobuf request
    edon::v1::StateStreamRequest request;
    request.mutable_eda()->Assign(window.eda.begin(), window.eda.end());
    request.mutable_temp()->Assign(window.temp.begin(), window.temp.end());
    request.mutable_bvp()->Assign(window.bvp.begin(), window.bvp.end());
    request.mutable_acc_x()->Assign(window.acc_x.begin(), window.acc_x.end());
    request.mutable_acc_y()->Assign(window.acc_y.begin(), window.acc_y.end());
    request.mutable_acc_z()->Assign(window.acc_z.begin(), window.acc_z.end());
    request.set_temp_c(window.temp_c);
    request.set_humidity(window.humidity);
    request.set_aqi(window.aqi);
    request.set_local_hour(window.local_hour);
    request.set_stream_mode(stream_mode);
    
    // Stream
    grpc::ClientContext context;
    edon::v1::StateStreamResponse response;
    
    std::unique_ptr<grpc::ClientReader<edon::v1::StateStreamResponse>> reader(
        pimpl_->stub()->StreamState(&context, request)
    );
    
    while (reader->Read(&response)) {
        CAVResponse result;
        result.cav_raw = response.cav_raw();
        result.cav_smooth = response.cav_smooth();
        result.state = response.state();
        result.parts.bio = response.parts().bio();
        result.parts.env = response.parts().env();
        result.parts.circadian = response.parts().circadian();
        result.parts.p_stress = response.parts().p_stress();
        result.controls.speed = response.controls().speed();
        result.controls.torque = response.controls().torque();
        result.controls.safety = response.controls().safety();
        result.timestamp_ms = response.timestamp_ms();
        
        callback(result);
    }
    
    grpc::Status status = reader->Finish();
    if (!status.ok()) {
        throw std::runtime_error("gRPC streaming failed: " + status.error_message());
    }
}

bool GRPCTransport::health() {
    try {
        // Create minimal request for health check
        edon::v1::CavRequest request;
        request.mutable_eda()->Resize(240, 0.0f);
        request.mutable_temp()->Resize(240, 0.0f);
        request.mutable_bvp()->Resize(240, 0.0f);
        request.mutable_acc_x()->Resize(240, 0.0f);
        request.mutable_acc_y()->Resize(240, 0.0f);
        request.mutable_acc_z()->Resize(240, 0.0f);
        request.set_temp_c(22.0f);
        request.set_humidity(50.0f);
        request.set_aqi(50);
        request.set_local_hour(12);
        
        edon::v1::CavResponse response;
        grpc::ClientContext context;
        context.set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(2));
        
        grpc::Status status = pimpl_->stub()->GetState(&context, request, &response);
        return status.ok();
    } catch (...) {
        return false;
    }
}

} // namespace edon

