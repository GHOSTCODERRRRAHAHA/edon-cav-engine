"""EDON CAV Engine Python SDK Client."""

import os
from typing import Dict, List, Optional, Any, Iterator

from .transport import TransportType
from .rest_transport import RESTTransport
from .grpc_transport import GRPCTransport
from .exceptions import EdonError, EdonHTTPError


class EdonClient:
    """
    Client for interacting with the EDON CAV Engine API.
    
    Supports both REST and gRPC transports. Uses environment variables
    for configuration:
    - EDON_BASE_URL: Base URL for REST API (default: http://127.0.0.1:8000)
    - EDON_API_TOKEN: API token for authentication (optional)
    
    Example:
        >>> from edon import EdonClient, TransportType
        >>> 
        >>> # REST transport (default)
        >>> client = EdonClient()
        >>> 
        >>> # Or with gRPC
        >>> client = EdonClient(transport=TransportType.GRPC)
        >>> 
        >>> window = {
        ...     "EDA": [0.1] * 240,
        ...     "TEMP": [36.5] * 240,
        ...     "BVP": [0.5] * 240,
        ...     "ACC_x": [0.0] * 240,
        ...     "ACC_y": [0.0] * 240,
        ...     "ACC_z": [1.0] * 240,
        ...     "temp_c": 22.0,
        ...     "humidity": 50.0,
        ...     "aqi": 35,
        ...     "local_hour": 14,
        ... }
        >>> 
        >>> result = client.cav(window)
        >>> print(result["state"])
    """
    
    def __init__(
        self,
        base_url: Optional[str] = None,
        api_key: Optional[str] = None,
        timeout: float = 5.0,
        max_retries: int = 2,
        verbose: bool = False,
        transport: TransportType = TransportType.REST,
        grpc_host: str = "localhost",
        grpc_port: int = 50051,
    ):
        """
        Initialize the EDON client.
        
        Args:
            base_url: Base URL of the EDON API (for REST). If not provided, reads from
                     EDON_BASE_URL env var, or defaults to http://127.0.0.1:8000
            api_key: API token for authentication (REST only). If not provided, reads from
                    EDON_API_TOKEN env var
            timeout: Request timeout in seconds (default: 5.0)
            max_retries: Maximum number of retries on 5xx or connection errors (default: 2)
            verbose: If True, log requests to stdout (default: False)
            transport: Transport layer type - REST or GRPC (default: REST)
            grpc_host: gRPC server host (default: localhost)
            grpc_port: gRPC server port (default: 50051)
        """
        self.transport_type = transport
        self.verbose = verbose
        
        # Initialize transport layer
        if transport == TransportType.REST:
            base_url = base_url or os.getenv("EDON_BASE_URL", "http://127.0.0.1:8000")
            api_key = api_key or os.getenv("EDON_API_TOKEN")
            self.transport = RESTTransport(
                base_url=base_url,
                api_key=api_key,
                timeout=timeout,
                max_retries=max_retries,
            )
        elif transport == TransportType.GRPC:
            self.transport = GRPCTransport(host=grpc_host, port=grpc_port)
        else:
            raise ValueError(f"Unsupported transport type: {transport}")
    
    def cav(self, window: Dict[str, Any]) -> Dict[str, Any]:
        """
        Compute CAV from a single sensor window.
        
        Args:
            window: Sensor window dict with:
                   - EDA, TEMP, BVP, ACC_x, ACC_y, ACC_z (each 240 floats)
                   - temp_c, humidity, aqi, local_hour (environmental data)
        
        Returns:
            CAV response with 'cav_raw', 'cav_smooth', 'state', 'parts', and optional 'controls' (gRPC)
            
        Raises:
            EdonHTTPError: If the request fails (REST)
            EdonError: If the request fails (gRPC)
        """
        try:
            return self.transport.compute_cav(window)
        except Exception as e:
            if self.transport_type == TransportType.REST:
                if isinstance(e, EdonHTTPError):
                    raise
                raise EdonHTTPError(f"CAV computation failed: {str(e)}", status_code=500) from e
            else:
                if isinstance(e, EdonError):
                    raise
                raise EdonError(f"CAV computation failed: {str(e)}") from e
    
    def cav_batch(self, windows: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Compute CAV for multiple sensor windows in batch (REST only).
        
        Args:
            windows: List of sensor window dicts (same format as cav())
        
        Returns:
            List of CAV results, each with 'ok', 'cav_raw', 'cav_smooth', 'state', 'parts'
            or 'error' if processing failed
            
        Raises:
            EdonError: If gRPC transport is used (batch not supported)
        """
        if self.transport_type != TransportType.REST:
            raise EdonError("cav_batch() is only available for REST transport")
        
        # Use REST transport's session directly
        import requests
        url = f"{self.transport.base_url}/oem/cav/batch"
        headers = self.transport._get_headers()
        
        try:
            response = requests.post(
                url,
                json={"windows": windows},
                headers=headers,
                timeout=self.transport.timeout,
            )
            response.raise_for_status()
            data = response.json()
            return data.get("results", [])
        except Exception as e:
            raise EdonHTTPError(f"Batch CAV computation failed: {str(e)}", status_code=500) from e
    
    def stream(self, window: Dict[str, Any]) -> Iterator[Dict[str, Any]]:
        """
        Stream CAV updates (server push).
        
        Args:
            window: Sensor window dict (same format as cav())
        
        Yields:
            CAV response dicts as they arrive from the server
        """
        try:
            yield from self.transport.stream(window)
        except Exception as e:
            if self.transport_type == TransportType.REST:
                if isinstance(e, EdonHTTPError):
                    raise
                raise EdonHTTPError(f"Streaming failed: {str(e)}", status_code=500) from e
            else:
                if isinstance(e, EdonError):
                    raise
                raise EdonError(f"Streaming failed: {str(e)}") from e
    
    def classify(self, window: Dict[str, Any]) -> str:
        """
        Classify state from sensor window (convenience method).
        
        Args:
            window: Sensor window dict (same format as cav())
        
        Returns:
            State string: 'overload', 'balanced', 'focus', or 'restorative'
        """
        result = self.cav(window)
        return result.get("state", "unknown")
    
    def health(self) -> Dict[str, Any]:
        """
        Check API health status.
        
        Returns:
            Health response with 'ok' and transport-specific fields
        """
        return self.transport.health()
    
    def close(self):
        """Close transport connections (gRPC only)."""
        if hasattr(self.transport, 'close'):
            self.transport.close()

